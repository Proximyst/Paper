From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Mariell Hoversholm <proximyst@proximyst.com>
Date: Tue, 5 Jan 2021 19:22:31 +0100
Subject: [PATCH] Entity collisions


diff --git a/src/main/java/net/minecraft/server/AxisAlignedBB.java b/src/main/java/net/minecraft/server/AxisAlignedBB.java
index ed9b2f9adfecdc6d1b9925579ec510657adde11f..df499effa57372c933f98e813f87af8cbfaa01ee 100644
--- a/src/main/java/net/minecraft/server/AxisAlignedBB.java
+++ b/src/main/java/net/minecraft/server/AxisAlignedBB.java
@@ -108,6 +108,7 @@ public class AxisAlignedBB {
         return new AxisAlignedBB(d3, d4, d5, d6, d7, d8);
     }
 
+    public final AxisAlignedBB offset(Vec3D vec3d) { return this.b(vec3d); } // Paper - OBFHELPER
     public AxisAlignedBB b(Vec3D vec3d) {
         return this.b(vec3d.x, vec3d.y, vec3d.z);
     }
@@ -185,6 +186,7 @@ public class AxisAlignedBB {
         return new AxisAlignedBB(d0, d1, d2, d3, d4, d5);
     }
 
+    public AxisAlignedBB move(double x, double y, double z) { return this.d(x, y, z); } // Paper - OBFHELPER
     public AxisAlignedBB d(double d0, double d1, double d2) {
         return new AxisAlignedBB(this.minX + d0, this.minY + d1, this.minZ + d2, this.maxX + d0, this.maxY + d1, this.maxZ + d2);
     }
@@ -193,6 +195,7 @@ public class AxisAlignedBB {
         return new AxisAlignedBB(this.minX + (double) blockposition.getX(), this.minY + (double) blockposition.getY(), this.minZ + (double) blockposition.getZ(), this.maxX + (double) blockposition.getX(), this.maxY + (double) blockposition.getY(), this.maxZ + (double) blockposition.getZ());
     }
 
+    public AxisAlignedBB add(Vec3D vector) { return this.c(vector); } // Paper - OBFHELPER
     public AxisAlignedBB c(Vec3D vec3d) {
         return this.d(vec3d.x, vec3d.y, vec3d.z);
     }
@@ -225,14 +228,17 @@ public class AxisAlignedBB {
         return (d0 + d1 + d2) / 3.0D;
     }
 
+    public final double getMagnitudeX() { return this.b(); } // Paper - OBFHELPER
     public double b() {
         return this.maxX - this.minX;
     }
 
+    public final double getMagnitudeY() { return this.c(); } // Paper - OBFHELPER
     public double c() {
         return this.maxY - this.minY;
     }
 
+    public final double getMagnitudeZ() { return this.d(); } // Paper - OBFHELPER
     public double d() {
         return this.maxZ - this.minZ;
     }
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index d9021fde3d0908dc89384617055874ac356a8fcf..f19dd322d6b55afd5277be4b182e47a518d4fe3d 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Iterators;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.objects.Object2DoubleArrayMap;
@@ -14,39 +15,39 @@ import java.util.Locale;
 import java.util.Optional;
 import java.util.Random;
 import java.util.Set;
+import java.util.Spliterators;
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Supplier;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
-
-// CraftBukkit start
 import org.bukkit.Bukkit;
 import org.bukkit.Location;
 import org.bukkit.Server;
 import org.bukkit.block.BlockFace;
 import org.bukkit.command.CommandSender;
-import org.bukkit.craftbukkit.event.CraftPortalEvent;
-import org.bukkit.entity.Hanging;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.entity.Vehicle;
-import org.bukkit.event.entity.EntityCombustByEntityEvent;
-import org.bukkit.event.hanging.HangingBreakByEntityEvent;
-import org.bukkit.event.vehicle.VehicleBlockCollisionEvent;
-import org.bukkit.event.vehicle.VehicleEnterEvent;
-import org.bukkit.event.vehicle.VehicleExitEvent;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.entity.CraftEntity;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.event.CraftPortalEvent;
+import org.bukkit.entity.Hanging;
+import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Pose;
+import org.bukkit.entity.Vehicle;
 import org.bukkit.event.entity.EntityAirChangeEvent;
+import org.bukkit.event.entity.EntityCombustByEntityEvent;
 import org.bukkit.event.entity.EntityCombustEvent;
 import org.bukkit.event.entity.EntityDropItemEvent;
 import org.bukkit.event.entity.EntityPortalEvent;
 import org.bukkit.event.entity.EntityPoseChangeEvent;
+import org.bukkit.event.hanging.HangingBreakByEntityEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
+import org.bukkit.event.vehicle.VehicleBlockCollisionEvent;
+import org.bukkit.event.vehicle.VehicleEnterEvent;
+import org.bukkit.event.vehicle.VehicleExitEvent;
 import org.bukkit.plugin.PluginManager;
 // CraftBukkit end
 
@@ -136,7 +137,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
     public double D;
     public double E;
     public double F;
-    public float G;
+    public float G; public final float getMaxUpStep() { return this.G; } // Paper - OBFHELPER
     public boolean noclip;
     public float I;
     protected final Random random;
@@ -619,7 +620,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
             // Paper end
 
             vec3d = this.a(vec3d, enummovetype);
-            Vec3D vec3d1 = this.g(vec3d);
+            Vec3D vec3d1 = this.collideWithCollisionBox(vec3d); // Paper - rework collisions: rename method
 
             if (vec3d1.g() > 1.0E-7D) {
                 this.a(this.getBoundingBox().c(vec3d1));
@@ -815,66 +816,86 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
         return d0;
     }
 
-    private Vec3D g(Vec3D vec3d) {
+    // Paper start - rework collisions
+    private List<VoxelShape> calculateCollidingEntities(AxisAlignedBB aabb) {
+        if (aabb.getAverageSideLength() < 1.0E-7D) {
+            return Collections.emptyList();
+        }
+
+        AxisAlignedBB grown = aabb.grow(1.0E-7D);
+        return Lists.transform(
+            this.world.getEntities(
+                this,
+                grown,
+                (java.util.function.Predicate<? super Entity>) entity ->
+                    entity.getBoundingBox().intersects(grown)
+                        && this.collidableWith(entity)),
+            entity -> VoxelShapes.of(entity.getBoundingBox())
+        );
+    }
+
+    private Vec3D collideWithCollisionBox(Vec3D vec3d) {
         AxisAlignedBB axisalignedbb = this.getBoundingBox();
         VoxelShapeCollision voxelshapecollision = VoxelShapeCollision.a(this);
-        VoxelShape voxelshape = this.world.getWorldBorder().c();
-        Stream<VoxelShape> stream = !this.world.getWorldBorder().isInBounds(axisalignedbb) ? Stream.empty() : Stream.of(voxelshape); // Paper
-        Stream<VoxelShape> stream1 = this.world.c(this, axisalignedbb.b(vec3d), (entity) -> {
-            return true;
-        });
-        StreamAccumulator<VoxelShape> streamaccumulator = new StreamAccumulator<>(Stream.concat(stream1, stream));
-        Vec3D vec3d1 = vec3d.g() == 0.0D ? vec3d : a(this, vec3d, axisalignedbb, this.world, voxelshapecollision, streamaccumulator);
+        VoxelShape borderShape = this.world.getWorldBorder().asVoxelShape();
+
+        boolean isWithinWorldBorder = this.world.getWorldBorder().isInBounds(axisalignedbb);
+        List<VoxelShape> colliders = this.calculateCollidingEntities(axisalignedbb.offset(vec3d));
+        Supplier<Iterator<VoxelShape>> collisionIterator = () -> isWithinWorldBorder
+            ? Iterators.concat(colliders.iterator(), Iterators.singletonIterator(borderShape))
+            : colliders.iterator();
+
+        Vec3D vec3d1 = vec3d.magnitude() == 0.0D ? vec3d : collideBoundingBoxHueristically(this, vec3d, axisalignedbb, this.world, voxelshapecollision, collisionIterator);
         boolean flag = vec3d.x != vec3d1.x;
         boolean flag1 = vec3d.y != vec3d1.y;
         boolean flag2 = vec3d.z != vec3d1.z;
         boolean flag3 = this.onGround || flag1 && vec3d.y < 0.0D;
 
         if (this.G > 0.0F && flag3 && (flag || flag2)) {
-            Vec3D vec3d2 = a(this, new Vec3D(vec3d.x, (double) this.G, vec3d.z), axisalignedbb, this.world, voxelshapecollision, streamaccumulator);
-            Vec3D vec3d3 = a(this, new Vec3D(0.0D, (double) this.G, 0.0D), axisalignedbb.b(vec3d.x, 0.0D, vec3d.z), this.world, voxelshapecollision, streamaccumulator);
+            Vec3D vec3d2 = collideBoundingBoxHueristically(this, new Vec3D(vec3d.x, this.getMaxUpStep(), vec3d.z), axisalignedbb, this.world, voxelshapecollision, collisionIterator);
+            Vec3D vec3d3 = collideBoundingBoxHueristically(this, new Vec3D(0.0D, this.getMaxUpStep(), 0.0D), axisalignedbb.expand(vec3d.x, 0.0D, vec3d.z), this.world, voxelshapecollision, collisionIterator);
 
-            if (vec3d3.y < (double) this.G) {
-                Vec3D vec3d4 = a(this, new Vec3D(vec3d.x, 0.0D, vec3d.z), axisalignedbb.c(vec3d3), this.world, voxelshapecollision, streamaccumulator).e(vec3d3);
+            if (vec3d3.y < (double) this.getMaxUpStep()) {
+                Vec3D vec3d4 = collideBoundingBoxHueristically(this, new Vec3D(vec3d.x, 0.0D, vec3d.z), axisalignedbb.add(vec3d3), this.world, voxelshapecollision, collisionIterator).add(vec3d3);
 
-                if (c(vec3d4) > c(vec3d2)) {
+                if (getHorizontalDistanceSquared(vec3d4) > getHorizontalDistanceSquared(vec3d2)) {
                     vec3d2 = vec3d4;
                 }
             }
 
-            if (c(vec3d2) > c(vec3d1)) {
-                return vec3d2.e(a(this, new Vec3D(0.0D, -vec3d2.y + vec3d.y, 0.0D), axisalignedbb.c(vec3d2), this.world, voxelshapecollision, streamaccumulator));
+            if (getHorizontalDistanceSquared(vec3d2) > getHorizontalDistanceSquared(vec3d1)) {
+                return vec3d2.add(collideBoundingBoxHueristically(this, new Vec3D(0.0D, -vec3d2.y + vec3d.y, 0.0D), axisalignedbb.add(vec3d2), this.world, voxelshapecollision, collisionIterator));
             }
         }
 
         return vec3d1;
     }
 
+    public static double getHorizontalDistanceSquared(Vec3D vector) { return c(vector); } // Paper - OBFHELPER
     public static double c(Vec3D vec3d) {
         return vec3d.x * vec3d.x + vec3d.z * vec3d.z;
     }
 
-    public static Vec3D a(@Nullable Entity entity, Vec3D vec3d, AxisAlignedBB axisalignedbb, World world, VoxelShapeCollision voxelshapecollision, StreamAccumulator<VoxelShape> streamaccumulator) {
-        boolean flag = vec3d.x == 0.0D;
-        boolean flag1 = vec3d.y == 0.0D;
-        boolean flag2 = vec3d.z == 0.0D;
-
-        if ((!flag || !flag1) && (!flag || !flag2) && (!flag1 || !flag2)) {
-            StreamAccumulator<VoxelShape> streamaccumulator1 = new StreamAccumulator<>(Stream.concat(streamaccumulator.a(), world.b(entity, axisalignedbb.b(vec3d))));
+    public static Vec3D collideBoundingBoxHueristically(@Nullable Entity entity, Vec3D vec3d, AxisAlignedBB axisalignedbb, World world, VoxelShapeCollision voxelshapecollision, Supplier<Iterator<VoxelShape>> supplier) {
+        boolean zeroX = vec3d.x == 0.0D;
+        boolean zeroY = vec3d.y == 0.0D;
+        boolean zeroZ = vec3d.z == 0.0D;
 
-            return a(vec3d, axisalignedbb, streamaccumulator1);
+        if ((!zeroX || !zeroY) && (!zeroX || !zeroZ) && (!zeroY || !zeroZ)) {
+            return collideBoundingBoxLegacy(vec3d, axisalignedbb, () -> Iterators.concat(supplier.get(), Spliterators.iterator(new VoxelShapeSpliterator(world, entity, axisalignedbb.offset(vec3d)))));
         } else {
-            return a(vec3d, axisalignedbb, world, voxelshapecollision, streamaccumulator);
+            return collideBoundingBox(vec3d, axisalignedbb, world, voxelshapecollision, supplier);
         }
     }
+    // Paper end
 
-    public static Vec3D a(Vec3D vec3d, AxisAlignedBB axisalignedbb, StreamAccumulator<VoxelShape> streamaccumulator) {
+    public static Vec3D collideBoundingBoxLegacy(Vec3D vec3d, AxisAlignedBB axisalignedbb, Supplier<Iterator<VoxelShape>> iterator) { // Paper
         double d0 = vec3d.x;
         double d1 = vec3d.y;
         double d2 = vec3d.z;
 
         if (d1 != 0.0D) {
-            d1 = VoxelShapes.a(EnumDirection.EnumAxis.Y, axisalignedbb, streamaccumulator.a(), d1);
+            d1 = VoxelShapes.calculatePushVelocity(EnumDirection.EnumAxis.Y, axisalignedbb, iterator.get(), d1); // Paper
             if (d1 != 0.0D) {
                 axisalignedbb = axisalignedbb.d(0.0D, d1, 0.0D);
             }
@@ -883,33 +904,33 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
         boolean flag = Math.abs(d0) < Math.abs(d2);
 
         if (flag && d2 != 0.0D) {
-            d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, streamaccumulator.a(), d2);
+            d2 = VoxelShapes.calculatePushVelocity(EnumDirection.EnumAxis.Z, axisalignedbb, iterator.get(), d2); // Paper
             if (d2 != 0.0D) {
                 axisalignedbb = axisalignedbb.d(0.0D, 0.0D, d2);
             }
         }
 
         if (d0 != 0.0D) {
-            d0 = VoxelShapes.a(EnumDirection.EnumAxis.X, axisalignedbb, streamaccumulator.a(), d0);
+            d0 = VoxelShapes.calculatePushVelocity(EnumDirection.EnumAxis.X, axisalignedbb, iterator.get(), d0); // Paper
             if (!flag && d0 != 0.0D) {
                 axisalignedbb = axisalignedbb.d(d0, 0.0D, 0.0D);
             }
         }
 
         if (!flag && d2 != 0.0D) {
-            d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, streamaccumulator.a(), d2);
+            d2 = VoxelShapes.calculatePushVelocity(EnumDirection.EnumAxis.Z, axisalignedbb, iterator.get(), d2); // Paper
         }
 
         return new Vec3D(d0, d1, d2);
     }
 
-    public static Vec3D a(Vec3D vec3d, AxisAlignedBB axisalignedbb, IWorldReader iworldreader, VoxelShapeCollision voxelshapecollision, StreamAccumulator<VoxelShape> streamaccumulator) {
+    public static Vec3D collideBoundingBox(Vec3D vec3d, AxisAlignedBB axisalignedbb, IWorldReader iworldreader, VoxelShapeCollision voxelshapecollision, Supplier<Iterator<VoxelShape>> iterator) { // Paper
         double d0 = vec3d.x;
         double d1 = vec3d.y;
         double d2 = vec3d.z;
 
         if (d1 != 0.0D) {
-            d1 = VoxelShapes.a(EnumDirection.EnumAxis.Y, axisalignedbb, iworldreader, d1, voxelshapecollision, streamaccumulator.a());
+            d1 = VoxelShapes.calculatePushVelocity(EnumDirection.EnumAxis.Y, axisalignedbb, iworldreader, d1, voxelshapecollision, iterator.get()); // Paper
             if (d1 != 0.0D) {
                 axisalignedbb = axisalignedbb.d(0.0D, d1, 0.0D);
             }
@@ -918,21 +939,21 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
         boolean flag = Math.abs(d0) < Math.abs(d2);
 
         if (flag && d2 != 0.0D) {
-            d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, iworldreader, d2, voxelshapecollision, streamaccumulator.a());
+            d2 = VoxelShapes.calculatePushVelocity(EnumDirection.EnumAxis.Z, axisalignedbb, iworldreader, d2, voxelshapecollision, iterator.get()); // Paper
             if (d2 != 0.0D) {
                 axisalignedbb = axisalignedbb.d(0.0D, 0.0D, d2);
             }
         }
 
         if (d0 != 0.0D) {
-            d0 = VoxelShapes.a(EnumDirection.EnumAxis.X, axisalignedbb, iworldreader, d0, voxelshapecollision, streamaccumulator.a());
+            d0 = VoxelShapes.calculatePushVelocity(EnumDirection.EnumAxis.X, axisalignedbb, iworldreader, d0, voxelshapecollision, iterator.get()); // Paper
             if (!flag && d0 != 0.0D) {
                 axisalignedbb = axisalignedbb.d(d0, 0.0D, 0.0D);
             }
         }
 
         if (!flag && d2 != 0.0D) {
-            d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, iworldreader, d2, voxelshapecollision, streamaccumulator.a());
+            d2 = VoxelShapes.calculatePushVelocity(EnumDirection.EnumAxis.Z, axisalignedbb, iworldreader, d2, voxelshapecollision, iterator.get()); // Paper
         }
 
         return new Vec3D(d0, d1, d2);
@@ -1954,6 +1975,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
         return EnumInteractionResult.PASS;
     }
 
+    public final boolean collidableWith(Entity entity) { return this.j(entity); } // Paper - OBFHELPER
     public boolean j(Entity entity) {
         return entity.aZ() && !this.isSameVehicle(entity);
     }
diff --git a/src/main/java/net/minecraft/server/EnumAxisCycle.java b/src/main/java/net/minecraft/server/EnumAxisCycle.java
index a7c2543fdd4d5f6a04c45ec42472837ccaea9619..25d357b63a67e636a2f14a22df6c2456e336ac11 100644
--- a/src/main/java/net/minecraft/server/EnumAxisCycle.java
+++ b/src/main/java/net/minecraft/server/EnumAxisCycle.java
@@ -26,12 +26,12 @@ public enum EnumAxisCycle {
 
         @Override
         public EnumDirection.EnumAxis a(EnumDirection.EnumAxis enumdirection_enumaxis) {
-            return null.d[Math.floorMod(enumdirection_enumaxis.ordinal() + 1, 3)];
+            return d[Math.floorMod(enumdirection_enumaxis.ordinal() + 1, 3)]; // Paper - decomp fix
         }
 
         @Override
         public EnumAxisCycle a() {
-            return null.BACKWARD;
+            return BACKWARD; // Paper - decomp fix
         }
     },
     BACKWARD {
@@ -42,12 +42,12 @@ public enum EnumAxisCycle {
 
         @Override
         public EnumDirection.EnumAxis a(EnumDirection.EnumAxis enumdirection_enumaxis) {
-            return null.d[Math.floorMod(enumdirection_enumaxis.ordinal() - 1, 3)];
+            return d[Math.floorMod(enumdirection_enumaxis.ordinal() - 1, 3)]; // Paper - decomp fix
         }
 
         @Override
         public EnumAxisCycle a() {
-            return null.FORWARD;
+            return FORWARD; // Paper - decomp fix
         }
     };
 
@@ -62,6 +62,7 @@ public enum EnumAxisCycle {
 
     public abstract EnumAxisCycle a();
 
+    public static EnumAxisCycle between(EnumDirection.EnumAxis axis1, EnumDirection.EnumAxis axis2) { return a(axis1, axis2); } // Paper - OBFHELPER
     public static EnumAxisCycle a(EnumDirection.EnumAxis enumdirection_enumaxis, EnumDirection.EnumAxis enumdirection_enumaxis1) {
         return EnumAxisCycle.e[Math.floorMod(enumdirection_enumaxis1.ordinal() - enumdirection_enumaxis.ordinal(), 3)];
     }
diff --git a/src/main/java/net/minecraft/server/Vec3D.java b/src/main/java/net/minecraft/server/Vec3D.java
index 7f05587d42b7cdb09552277ec2e467f0edf06f10..295be00de1e98b976bf7183f4f81aae0e9f263d9 100644
--- a/src/main/java/net/minecraft/server/Vec3D.java
+++ b/src/main/java/net/minecraft/server/Vec3D.java
@@ -61,6 +61,7 @@ public class Vec3D implements IPosition {
         return this.add(-d0, -d1, -d2);
     }
 
+    public Vec3D add(Vec3D vector) { return this.e(vector); } // Paper - OBFHELPER
     public Vec3D e(Vec3D vec3d) {
         return this.add(vec3d.x, vec3d.y, vec3d.z);
     }
@@ -113,6 +114,7 @@ public class Vec3D implements IPosition {
         return (double) MathHelper.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
     }
 
+    public final double magnitude() { return this.g(); } // Paper - OBFHELPER
     public double g() {
         return this.x * this.x + this.y * this.y + this.z * this.z;
     }
diff --git a/src/main/java/net/minecraft/server/VoxelShape.java b/src/main/java/net/minecraft/server/VoxelShape.java
index eb926b74e17fb2f88c1d6ce2fb546541f8e6e274..bdeb8dfec0d4b7e7f79835593f3419a8739cfa83 100644
--- a/src/main/java/net/minecraft/server/VoxelShape.java
+++ b/src/main/java/net/minecraft/server/VoxelShape.java
@@ -141,6 +141,7 @@ public abstract class VoxelShape {
         }
     }
 
+    public final double calculateMaxDistance(EnumDirection.EnumAxis axis, AxisAlignedBB aabb, double maxDistance) { return this.a(axis, aabb, maxDistance); } // Paper - OBFHELPER
     public double a(EnumDirection.EnumAxis enumdirection_enumaxis, AxisAlignedBB axisalignedbb, double d0) {
         return this.a(EnumAxisCycle.a(enumdirection_enumaxis, EnumDirection.EnumAxis.X), axisalignedbb, d0);
     }
diff --git a/src/main/java/net/minecraft/server/VoxelShapes.java b/src/main/java/net/minecraft/server/VoxelShapes.java
index e21c747b6c39155c44bf30860681d67b0b29fb12..181974ef6cc08e8880a1d1a9105f95e785f33e56 100644
--- a/src/main/java/net/minecraft/server/VoxelShapes.java
+++ b/src/main/java/net/minecraft/server/VoxelShapes.java
@@ -176,6 +176,19 @@ public final class VoxelShapes {
         });
     }
 
+    // Paper start
+    public static double calculatePushVelocity(EnumDirection.EnumAxis enumdirection_enumaxis, AxisAlignedBB axisalignedbb, java.util.Iterator<VoxelShape> iterator, double d0) {
+        // This is a copy of the method below (#a).
+        for (; iterator.hasNext(); d0 = ((VoxelShape) iterator.next()).a(enumdirection_enumaxis, axisalignedbb, d0)) {
+            if (Math.abs(d0) < 1.0E-7D) {
+                return 0.0D;
+            }
+        }
+
+        return d0;
+    }
+    // Paper end
+
     public static double a(EnumDirection.EnumAxis enumdirection_enumaxis, AxisAlignedBB axisalignedbb, Stream<VoxelShape> stream, double d0) {
         for (Iterator iterator = stream.iterator(); iterator.hasNext(); d0 = ((VoxelShape) iterator.next()).a(enumdirection_enumaxis, axisalignedbb, d0)) {
             if (Math.abs(d0) < 1.0E-7D) {
@@ -190,6 +203,94 @@ public final class VoxelShapes {
         return a(axisalignedbb, iworldreader, d0, voxelshapecollision, EnumAxisCycle.a(enumdirection_enumaxis, EnumDirection.EnumAxis.Z), stream);
     }
 
+    // Paper start
+    public static double calculatePushVelocity(EnumDirection.EnumAxis axis, AxisAlignedBB aabb, IWorldReader world, double initialVelocity, VoxelShapeCollision shapeCollision, java.util.Iterator<VoxelShape> shapes) {
+        return calculatePushVelocity(aabb, world, initialVelocity, shapeCollision, EnumAxisCycle.between(axis, EnumDirection.EnumAxis.Z), shapes);
+    }
+
+    private static double calculatePushVelocity(AxisAlignedBB axisalignedbb, IWorldReader iworldreader, double d0, VoxelShapeCollision voxelshapecollision, EnumAxisCycle enumaxiscycle, java.util.Iterator<VoxelShape> stream) {
+        // This is literally copy-pasting the method below (#a), with one minor `#forEach` -> `for`.
+
+        if (axisalignedbb.b() >= 1.0E-6D && axisalignedbb.c() >= 1.0E-6D && axisalignedbb.d() >= 1.0E-6D) {
+            if (Math.abs(d0) < 1.0E-7D) {
+                return 0.0D;
+            } else {
+                EnumAxisCycle enumaxiscycle1 = enumaxiscycle.a();
+                EnumDirection.EnumAxis enumdirection_enumaxis = enumaxiscycle1.a(EnumDirection.EnumAxis.X);
+                EnumDirection.EnumAxis enumdirection_enumaxis1 = enumaxiscycle1.a(EnumDirection.EnumAxis.Y);
+                EnumDirection.EnumAxis enumdirection_enumaxis2 = enumaxiscycle1.a(EnumDirection.EnumAxis.Z);
+                BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+                int i = MathHelper.floor(axisalignedbb.a(enumdirection_enumaxis) - 1.0E-7D) - 1;
+                int j = MathHelper.floor(axisalignedbb.b(enumdirection_enumaxis) + 1.0E-7D) + 1;
+                int k = MathHelper.floor(axisalignedbb.a(enumdirection_enumaxis1) - 1.0E-7D) - 1;
+                int l = MathHelper.floor(axisalignedbb.b(enumdirection_enumaxis1) + 1.0E-7D) + 1;
+                double d1 = axisalignedbb.a(enumdirection_enumaxis2) - 1.0E-7D;
+                double d2 = axisalignedbb.b(enumdirection_enumaxis2) + 1.0E-7D;
+                boolean flag = d0 > 0.0D;
+                int i1 = flag ? MathHelper.floor(axisalignedbb.b(enumdirection_enumaxis2) - 1.0E-7D) - 1 : MathHelper.floor(axisalignedbb.a(enumdirection_enumaxis2) + 1.0E-7D) + 1;
+                int j1 = a(d0, d1, d2);
+                int k1 = flag ? 1 : -1;
+                int l1 = i1;
+
+                while (true) {
+                    if (flag) {
+                        if (l1 > j1) {
+                            break;
+                        }
+                    } else if (l1 < j1) {
+                        break;
+                    }
+
+                    for (int i2 = i; i2 <= j; ++i2) {
+                        for (int j2 = k; j2 <= l; ++j2) {
+                            int k2 = 0;
+
+                            if (i2 == i || i2 == j) {
+                                ++k2;
+                            }
+
+                            if (j2 == k || j2 == l) {
+                                ++k2;
+                            }
+
+                            if (l1 == i1 || l1 == j1) {
+                                ++k2;
+                            }
+
+                            if (k2 < 3) {
+                                blockposition_mutableblockposition.a(enumaxiscycle1, i2, j2, l1);
+                                IBlockData iblockdata = iworldreader.getTypeIfLoaded(blockposition_mutableblockposition); // Paper
+                                if (iblockdata == null) return 0.0D; // Paper
+
+                                if (!iblockdata.isAir() && (k2 != 1 || iblockdata.d()) && (k2 != 2 || iblockdata.a(Blocks.MOVING_PISTON))) { // Paper
+                                    d0 = iblockdata.b((IBlockAccess) iworldreader, blockposition_mutableblockposition, voxelshapecollision).a(enumdirection_enumaxis2, axisalignedbb.d((double) (-blockposition_mutableblockposition.getX()), (double) (-blockposition_mutableblockposition.getY()), (double) (-blockposition_mutableblockposition.getZ())), d0);
+                                    if (Math.abs(d0) < 1.0E-7D) {
+                                        return 0.0D;
+                                    }
+
+                                    j1 = a(d0, d1, d2);
+                                }
+                            }
+                        }
+                    }
+
+                    l1 += k1;
+                }
+
+                // Paper start - change #forEach to a for-loop
+                double result = d0;
+                while (stream.hasNext()) {
+                    result = stream.next().calculateMaxDistance(enumdirection_enumaxis2, axisalignedbb, result);
+                }
+                return result;
+                // Paper end - change #forEach to a for-loop
+            }
+        } else {
+            return d0;
+        }
+    }
+    // Paper end
+
     private static double a(AxisAlignedBB axisalignedbb, IWorldReader iworldreader, double d0, VoxelShapeCollision voxelshapecollision, EnumAxisCycle enumaxiscycle, Stream<VoxelShape> stream) {
         if (axisalignedbb.b() >= 1.0E-6D && axisalignedbb.c() >= 1.0E-6D && axisalignedbb.d() >= 1.0E-6D) {
             if (Math.abs(d0) < 1.0E-7D) {
